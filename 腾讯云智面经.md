<!--
 * @Description: 
 * @Author: 曹俊
 * @Date: 2023-02-22 13:18:02
 * @LastEditors: 曹俊
 * @LastEditTime: 2023-03-05 21:31:24
-->
## 自我介绍
面试官你好，我叫曹俊，是一名来自湖南科技大学计算机科学与工程学院物联网工程专业的一名大四学生，在大学期间，无挂科，绩点3.0左右，有拿过奖学金以及校级奖励，主要实习经历是在学校的网络信息中心实习，在里面担任的是一名前端开发工程师，主要项目经验有实习期间的面对面签到系统以及阳光服务平台，其余的都是自己做的项目，有一个基于网易开放平台的云音乐移动端网页，项目是从0到1开发，并部署到服务器上实现在线访问，另一个是一个文件解析网页，能够将特定的docx文件解析为指定样式的网页，供二次使用，并部署到GitHub pages上支持在线访问

## 项目难点：可以说一下rollup打包不能引入变量，只能引入字面量
## 项目亮点：
# 项目亮点：

## 开发工具:Vue3+Vite+pinia+Windicss+Vant+pnpm

- Vue3:使用 Composition API 地 \<script setup> SFC 语法
- Vite：快
- pinia:直接的, 类型安全的, 使用 Composition api 的轻便灵活的 Vue 状态管理
- windicss：可以直接在类名里面写样式，可通过缩写提高写样式的效率
- pnpm：当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：
  - 如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。
  - 所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。
  - 因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！

## 插件方面

- 使用基于文件系统的路由，可以直接跳转到 pages 下的单文件组件
- vite-plugin-pages：可以为不同的界面设置不同的布局：

```js
<route lang="yaml">meta: layout: users</route>
```

- unplugin-vue-components: 组件自动导入
- unplugin-auto-import: 直接使用 Vue Composition API 等，无需导入
- vitejs/plugin-legacy:此插件为在构建生产时不支持这些功能的旧版浏览器提供支持。

## 打包部署方面：

- 采用 gzip 压缩，使文件大小压缩了近 70％
- 去除 console.log()函数，减少了代码体积

## 代码方面：

- 对输入搜索，昵称检测是否可用添加了防抖函数，减少了请求的次数
- 对列表数据进行懒加载，对表单数据进行预检验，减少了服务器请求的压力以及用户的等待时间
- 对常用的组件进行封装，提高了代码的可复用性

## 项目难点：

## 登录接口的话是分为测试登录和企业号登录，之前管理这两个接口是用一个布尔值管理，然后每次改完 bug，打包部署的时候容易将开发环境的接口部署上去，导致用户体验不佳

#### 解决方案：

#### 查看官网，了解：

- 默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令则运行在 production (生产) 模式。
- Vite 在一个特殊的 import.meta.env 对象上暴露环境变量。
- 为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE\_ 为前缀的变量才会暴露给经过 vite 处理的代码。所以可以定义

#### 解决方案：

- 在项目根目录写一个.env.devplopment 和 .env.production
- 然后为各自的文件增加相应的 Mode 以及 baseURL
- 最后在路由拦截器判断import.meta.env.MODE的值就可以调用不同的接口了
## 项目细节：权限怎么转换
## 如何判断一个数组
## 原型和原型链
## 浏览器的事件循环机制，和node有什么区别？
#### Node.js 和浏览器都采用了事件循环机制，下面分别介绍一下它们的不同之处。

- 浏览器的事件循环机制

  浏览器中的事件循环机制主要用于处理浏览器事件，如用户交互、网络请求等等。浏览器中的事件循环机制包括两个主要的部分：宏任务和微任务。

  - 宏任务：通常由浏览器（如 DOM 事件、定时器、资源请求等）触发，在每次事件循环中执行一次。
  - 微任务：通常由 JavaScript 代码触发，如异步执行的 Promise、MutationObserver 等，通常比宏任务执行更快。
  - 
  在每次事件循环中，所有的宏任务会先排队执行完毕，然后才会轮到微任务执行。在所有的微任务执行完毕后，会将任务队列置空，接着进入下一轮宏任务的执行。

- Node.js 的事件循环机制

  Node.js 中的事件循环机制主要用于处理 I/O 操作，其实现方式也是基于宏任务和微任务的区分。不过，由于 Node.js 中包含了大量的 I/O 操作和异步任务，因此其事件循环和浏览器有一些区别。

  具体来说，Node.js 的事件循环机制中，宏任务分为了几个不同的阶段，每个阶段都有其对应的微任务。这些阶段包括：

  - timer 阶段：处理定时器任务
  - pending callbacks 阶段：处理系统级回调，如 TCP 错误、定时器等
  - idle,prepare 阶段：系统内部使用
  - poll 阶段：处理 I/O 操作
  - check 阶段：处理 setImmediate 的回调
  - close callbacks 阶段：处理有关关闭事件的回调
  在每个阶段的执行过程中，都可以添加当前阶段所属的微任务，这样在当前阶段执行完成之后，会立即执行这些微任务。Node.js 的事件循环机制由 libuv 模块实现，具有高效和可扩展性等优势。

总结来说，Node.js 和浏览器的事件循环机制都是基于宏任务和微任务的设计，并且都通过异步操作来实现高效的性能。不过，它们的实现方式略有不同，需要在具体的应用场景下选择合适的方案。
## 浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来的流程 ：
获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）
解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）
根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）
进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置
进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来
## flex怎么实现两栏布局以及垂直居中
## JS的垃圾回收算法以及v8引擎的优化
#### JavaScript的垃圾回收算法涉及两种类型：标记清除算法和引用计数算法。

- 标记清除算法：

  当变量声明但从未分配任何值时，会分配一些内存，但由于此变量未使用，因此此内存空间被视为未使用空间。垃圾回收机制标记此未使用空间，然后清除已标记的空间。在这种情况下，JavaScript使用标记和清除算法。下面是标记和清除算法的过程：

- 垃圾回收器在内存中创建链表，并标记所有变量

- 垃圾回收器检查所有变量并且删除没有标记的变量。

  垃圾回收器在需要内存时重复上述过程

- 引用计数算法：

  - 引用计数算法是一种跟踪当前对象的引用数的算法。当有一个新对象时，引用计数器的值是1。当其他对象引用此对象时，引用计数器的值增加。

  - 当对象没有活动引用时，引用计数器的值会减少。当引用计数器的值为零时，对象了失去了对它的所有引用，可以被回收。

  这种算法的缺点是如果一个对象相互引用，即使没有外部引用，也不会被垃圾回收机制清除，因为对其他对象的引用计数不为零。

  由于引用计数算法存在这种缺陷，因此标记和清除算法是JavaScript中常用的垃圾回收算法。
  
#### V8 是一款 JavaScript 引擎，它使用垃圾回收机制来管理内存，并确保使用的内存不泄漏。V8 引擎的垃圾回收机制采用了分代回收的方式，即将内存分为新生代和老生代两部分，分别使用不同的回收算法来处理。

- 新生代垃圾回收机制
  
  新生代垃圾回收机制专门处理堆最新的对象，它将堆分成两个部分：From 和 To。新创建的对象被放入 From 空间，当 From 空间被填满后，V8 就会将 From 中存活的对象复制到 To 空间。然后，V8 会清空 From 空间并将其与 To 空间互换，这样 To 空间成为了新的 From 空间，而 From 空间成为了新的 To 空间。在这个过程中，垃圾回收机制会检查每个对象的生存期是否已经结束，如果已经结束，就会回收这些对象的内存。

- 老生代垃圾回收机制
  
  老生代垃圾回收机制处理存活时间较长的对象，通常是大型对象。由于这些对象的生命周期很长，不能像新生代垃圾回收机制那样复制和移动对象。因此，老生代垃圾回收机制使用标记-清除算法进行垃圾回收。这个算法包括两个过程：标记和清除。首先，垃圾回收器会遍历堆中的对象，并将所有可达对象标记为“存活”。然后，垃圾回收器会清除没有被标记为“存活”的对象。

总的来说，V8 引擎的垃圾回收机制主要是通过复制和清除来管理内存。新生代垃圾回收机制处理新创建的对象，而老生代垃圾回收机制处理存活时间较长的对象。这些机制使 V8 引擎可以高效地管理内存，并避免内存泄漏。






## 对重排重绘的理解
## 对前端工程化的理解
#### 前端工程化：指使用软件工程的技术与方法对前端开发的技术、工具、流程、经验、方案等指标标准化，它具备``模块化、组件化、规范化、自动化``四大特性，主要目的是``降低成本``与``增加效率``。
- 模块化：是指在文件层面上对代码与资源实现拆分与组装，将一个大文件拆分为互相依赖的小文件，再统一拼装与加载。各个模块功能独立，分模块来维护，组合方式更灵活，多人协作也互不干扰。例如：接口模块、资源模块、路由模块等。
- 组件化：是指在功能开发场景中，将具备通用功能的交互设计划分为模板、样式和逻辑组成的功能单元，是具体某个功能的封装，实现了代码更高层次的复用性，提升开发效率。组件的封装也是对象的封装，同样要做到高内聚低耦合，例如分页器、table表格、form表单等。
- 规范化：将一系列预设规范接入工程各个阶段，通过各项指标标准化开发者的工作流程，为每个开发者指明一个方向，引领着成员往该方向走。例如：eslint、stylelint、pre-commit等，拉齐代码标准，形成规范底线，方便不同人员等交叉维护。
- 自动化：指将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，常见自动化场景包括但不限于自动化构建、自动化测试、自动化打包、自动化发布和自动化部署等。在保证效率的同时，又解放了双手。
## http2.0有什么改进
## 对Xss和CSRF的理解
## 域名的层级关系
- DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。

- 在域名中，越靠右的位置表示其层级越高。

- 毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

- 实际上域名最后还有一个点，比如 www.server.com.，这个最后的一个点代表根域名。

- 也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。

- 所以域名的层级关系类似一个树状结构：

  - 根 DNS 服务器（.）
  - 顶级域 DNS 服务器（.com）
  - 权威 DNS 服务器（server.com）
## 域名解析的工作流程
- 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件（Hosts文件是一个本地的计算机文件，它可以把机器名字映射到特定的IP地址。 网络客户端会使用这个文件来访问特定的机器而不需要借助DNS服务器。）看，也没有，才会去问本地 DNS 服务器(也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
- 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
- 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
- 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
- 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
- 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
- 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

## 说一说DNS解析
- 首先会在「浏览器的缓存」中查找对应的 IP 地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给「本地 DNS 服务器」，在本地 DNS 服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地 DNS 服务器向「根域名服务器」发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地 DNS 服务器向「顶级域名服务器」发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地 DNS 服务器向「权威域名服务器」发送请求，域名服务器返回对应的结果
- 本地 DNS 服务器将返回结果保存在缓存中，便于下次使用
- 本地 DNS 服务器将返回结果返回给浏览器

### 递归查询和迭代查询

```md
# 递归查询:指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。

# 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
```

```md
# 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。
```
## Vue2和3的区别

## 算法题：找出一个字符串出现连续重复的字符，例如：输入'aaasfjkjkbbbdjkjssjccc'，输出：['aaa', 'bbb', 'ss', 'ccc']