<!--
 * @Description:
 * @Author: 曹俊
 * @Date: 2022-11-11 20:23:31
 * @LastEditors: 曹俊
 * @LastEditTime: 2023-03-08 22:31:44
-->

# 自我介绍
面试官你好，我叫曹俊，是一名来自湖南科技大学计算机科学与工程学院物联网工程专业的一名大四学生，在大学期间，无挂科，绩点3.0左右，有拿过奖学金以及校级奖励，主要实习经历是在学校的网络信息中心实习，在里面担任的是一名前端开发工程师，主要项目经验有实习期间的面对面签到系统以及阳光服务平台，其余的都是自己做的项目，有一个基于网易开放平台的云音乐移动端网页，项目是从0到1开发，并部署到服务器上实现在线访问，另一个是一个文件解析网页，能够将特定的docx文件解析为指定样式的网页，供二次使用，并部署到GitHub pages上支持在线访问
# 简历上可能问的问题：
- 在Vue中优化大数据量的页面渲染主要有以下几个方面：

  - 使用虚拟列表或者虚拟滚动等技术，只渲染可见区域内的数据。通过监听滚动事件并计算当前可见区域动态生成DOM节点，可以大大减少不必要的DOM节点渲染和计算，从而提升渲染效率。Vue 的第三方插件 vue-virtual-scroll-list 和 vue-virtual-scroll-tree 提供了常见的虚拟列表和虚拟树组件。

  - 利用Vue的computed计算属性实现数据格式转换和缓存。通过将大量的数据转换为Vue的响应式计算属性，可以减少重复渲染和计算，提升性能。在数据源更新时，Vue只会计算变更的部分和相关依赖，并实时更新渲染结果。

  - 合理使用Vue的v-if和v-for等指令来避免不必要的DOM元素渲染。除了虚拟列表等技术外，Vue也提供了一些指令来动态处理DOM元素的显隐和数据绑定。通过结合v-if和v-for等指令，可以避免不必要的DOM元素渲染，减少渲染负担。
- 前端常见的安全问题包括：

  - XSS攻击（Cross Site Scripting）：通过注入恶意脚本来控制网页展示内容，窃取用户数据。

  - CSRF攻击（Cross-Site Request Forgery）：攻击者通过欺骗用户发出伪造的请求，在用户不知情的情况下，偷偷攻击已登陆的网站。

  - 前端代码泄露：因为前端代码是开放的，容易泄露业务逻辑、敏感信息和密钥等信息。

  针对这些安全问题，可以采取以下对策：

  - XSS攻击对策：在对用户输入进行过滤，并对特殊字符进行转义，使用HttpOnly Cookie 来限制Cookie 被JavaScript读取。

  - CSRF 攻击对策：通过验证Referer来检查请求是否来自合法地址、加入随机码逻辑、验证token。

  - 前端代码泄露对策：使用模块化开发，分离公共模块/第三方模块与业务逻辑模块，不将密钥等信息直接写入代码，进行代码压缩混淆，保护源代码安全性。同时，定期审核产品模板，检查是否有可能的信息泄露风险。

- Node.js 常见面试题：

  - 什么是 Node.js？
Node.js 是一个使用 JavaScript 语言开发的开源、跨平台的运行时环境，它使得开发者可以在服务器端使用 JavaScript 进行开发。

  - Node.js 的优势是什么？
Node.js 的主要优势包括：

  - 事件驱动、非阻塞 I/O 模型；
  - 轻量、高效、易于扩展；
  - 使用 JavaScript，使得跨平台开发更为便捷。
  - Node.js 能够应对哪些类型的任务？
  - Node.js 不适合 CPU 密集型任务，但适合处理 I/O 密集型任务，比如网络通信、文件操作等等。

  - 什么是 NPM？
NPM（Node Package Manager）是 Node.js 的包管理工具，它允许开发者共享、安装和管理代码包。

  - 什么是回调函数？
回调函数是一种常用的编程模式，通常用于异步操作完成后的数据处理。在 Node.js 中，通过回调函数来处理异步操作是常见的做法。

  - 什么是模块？
模块是 Node.js 中对于代码组织的单位，一个模块可以被另一个模块所依赖，也可以依赖其他模块。Node.js 中实现模块化的方式是通过 CommonJS 规范。

  - Node.js 中的事件是什么？
Node.js 中的事件是事件驱动模型的基础。通过 events 模块，Node.js 中可以自定义事件和事件监听器，并通过事件来触发相应的处理逻辑。
- ES Module（ESM）和CommonJS（CJS）的区别
  ES Module（ESM）和CommonJS（CJS）都是用于 JavaScript 模块化的规范，用于组织和管理 JavaScript 代码，但它们有以下几点区别：

  - 语法不同：ESM采用import和export关键字来定义和导出模块，而CJS采用require和module.exports语法。

  - 代码执行时机不同：ESM是在编译时就可以确定，而 CJS 是在运行时确定的，所以如果是在浏览器环境下，需要先下载完整个 JS 文件才能去解析运行。

  - 加载方式不同：ESM是静态引入，通过在 HTML 的 module 标签或者 JavaScript 的 import 引入，所以他们能够在浏览器环境下完美地支持懒加载、异步等方式，而CJS是动态引入，只能通过代码的形式在程序运行时动态加载。

  - 变量绑定方式不同：ESM可以在导入的模块中，直接引用导出模块的变量，同时包含整个模块的变量，而CJS中所有导入都是传值赋值，导出的值会通过引用传递。

  综上所述，ES Module 是 ECMAScript（JavaScript）官方制定的模块化方案，跟浏览器的 ECMAScript 实现结合更紧密；CommonJS 是 Node.js 默认的模块化规范，更适用于服务端，可以动态加载模块并支持模块导入的缓存。

- 对前端工程化的理解：
  前端工程化是一种利用工具和流程优化前端开发流程的方法，旨在提高项目的可维护性、可扩展性和可复用性。它主要包括以下几个方面：

  - 模块化开发：模块化开发可以将复杂的代码分解成更小的、独立的模块，提高代码的可维护性和可复用性。

  - 自动化构建：自动化构建可以自动处理前端代码的编译、压缩、合并等工作，提高开发效率和代码质量。

  - 自动化测试：自动化测试可以自动运行测试用例，通过自动化的测试流程，可以减少手动测试的工作量，同时保证代码质量和稳定性。

  - 版本控制：版本控制可以记录代码的变化历史和归档备份，帮助开发者随时追踪代码的变化历史和进行协同开发。

  - 持续集成：持续集成可以通过自动化的方式不断集成和测试代码的更新，从而提供更加及时的反馈和更高的代码质量。

  综上所述，前端工程化是一种将前端开发流程自动化、标准化的方法，能够提高开发效率、代码质量和团队协作能力。


# Node面试题
## 问题
- 解释一下Node.js及其工作原理。
  -  Node.js是一个基于Chrome V8引擎的服务器端JavaScript运行环境。它采用事件驱动、非阻塞I/O模型，使其轻量、高效并具有良好的可扩展性。Node.js的工作原理是基于事件循环的，这意味着它在执行时将会以异步(callback)的方式处理用户请求。

- Node.js的优缺点是什么？
  -  Node.js的优点包括：高效率、低延迟、轻量、跨平台、良好的可扩展性、清晰的架构等。缺点包括：处理CPU密集型操作和多核处理的能力较弱、对于新手不够友好等。
- 解释一下事件驱动性的编程是什么意思。这对Node.js有什么影响？
  -  事件驱动编程是一种编程理念，通过异步(callback)方式处理用户请求，以最小的时间响应并处理更多的请求。这种编程方式更适用于I/O密集型操作，因为它无需等待系统调用，从而获得更高的并发性和更低的延迟。Node.js就是基于这种事件驱动性编程的方式而设计的。
- 什么是回调函数？在Node.js中，为什么会经常使用它们？
  -  回调函数是将一个函数作为参数传递给另一个函数，并在后者执行后被执行。在Node.js中，由于其异步特性，许多API都是基于回调函数的方式实现，以便在异步操作完成后获得结果。

- 解释一下Node.js中的事件循环是什么。这对Node.js有什么影响。
  - Node.js的事件循环是一个处理器在等待和处理事件消息的过程。它采用单线程模型，但利用事件和非阻塞I/O使单线程能够处理大量的并发连接。事件循环采用异步(callback)的方式处理用户请求，以最小的时间响应并处理更多请求。

- 什么是模块？以及在Node.js中如何使用模块？
  - 在Node.js中，每个文件都被视为一个模块。这使得其易于使用和组织代码。可以通过导出和导入的方式使用模块化的代码。

- 解释一下提高Node.js性能的技术。
  - Node.js提供了一些工具和技术，例如利用cahce加速之前已经加载过的模块、应用性能优化工具如PM2、Node-clinic、应用集群、代码优化等方法来提高Node.js的性能。

- 什么是Promise？解释一下如何在Node.js中使用Promise。
  - Promise是一种解决回调嵌套问题的新式Api，使代码更清晰易懂并更具可读性。在Node.js中，可以利用Promise实现更好的代码维护，避免回调函数过深嵌套的问题。

- 解释一下Node.js中的缓冲区(Buffer)是什么。
  - 缓冲区(Buffer)类似于数组，但也有一些重要的区别。它是一个被优化为处理二进制数的类数组对象。Node.js缓冲区使用在TCP流或文件系统操作等场景中处理数据，每当需要在Stream中传输数据时，就会发生缓冲操作。

- 如何在Node.js中进行调试？
  
  - 在Node.js中，可以使用内置的调试器或者第三方调试工具，例如Chrome DevTools Inspector扩展程序实现。可以通过控制台调用setBreakpoint函数来设置断点，也可以模拟使用Node.js解释器的命令行。

# 对路由原理的理解

## 路由（Routing）是Web应用程序中最核心的概念之一。它是指根据用户的请求路径，在不同页面之间进行切换或者加载不同的数据，从而实现页面的动态切换和更新。

#### 路由的原理可以从服务器和客户端两个方面来解释。

一、服务器端路由原理

#### 在服务器端，路由是指服务器如何处理接收到的客户端请求。当客户端发起一个请求时，服务器需要根据请求路径（URL）和请求方法（如GET、POST等）来决定如何响应客户端请求。

#### 服务器端路由的实现原理是：服务器通过监听HTTP请求，在请求到达之后，根据请求的URL和HTTP方法（GET、POST等）来判断客户端请求的资源，然后将请求转发给相应的控制器进行处理，最终返回响应结果给客户端。

二、客户端路由原理

#### 在客户端，路由通常是指前端路由（Front-end Routing），它是一种前端框架（如Angular、Vue、React等）实现的一种客户端路由方案。前端路由的原理是：在浏览器的单页面应用（SPA）中，改变URL地址路径的同时，使用JavaScript动态更新对应的页面内容，实现页面无刷新的更新和跳转。

#### 客户端路由的实现原理是：浏览器监听URL的变化，一旦URL发生了改变，前端路由就会根据URL的变化来切换页面。前端路由使用历史记录管理API（如pushState和replaceState）来实现该功能，这样，用户在切换页面时就可以以正常的方式管理浏览器的历史记录，同时可以实现单页面内的动态路由转换。

#### 总体来说，路由是指从一步步具体的请求中分离出来相对独立的概念，是Web应用程序中的核心技术之一。无论是服务器端路由还是客户端路由，路由都是实现页面切换、资源加载和请求处理的基础。










Try again
# js 数据类型以及存放位置

# js 判断数据类型的方法

# js 事件循环机制

## 事件循环机制：

- js 是单线程，为了防止代码阻塞，把任务分为：同步和异步任务
- 同步代码交给 js 引擎执行，异步代码交给宿主环境(node 或者浏览器)
- 同步代码放入执行栈中，异步代码等待特殊时机(比如定时器倒计时完成，点击按钮触发回调函数)送入到任务队列（分为微任务队列和宏任务队列）
- 先执行执行栈中的同步任务，由于微任务比宏任务先执行，就会先去查看微任务队列中是否有微任务，如果有就执行，没有就查看宏任务队列，有就执行，没有就继续查看微任务队列，反复循环，这个过程就是事件循环

# this 的指向

- 作为普通函数调用，this 指向 window
- 作为对象的方法调用，this 指向这个对象
- 使用 new 关键字对构造函数进行实例化，this 指向实例化的对象
- 箭头函数没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。
- 使用 call(),apply(),bind(),this 绑定这些方法的第一个参数
- 严格模式下，this 默认为 undefined
- setTimeout()的回调函数里面的 this 默认 指向 window 对象，所以用箭头函数可以直接获取到上下文的 this，可以不用变量保存 this

# 闭包

# 原型和原型链

# 作用域和作用域链

# var，let 和 const 的区别

# js 继承

# new 操作符具体干了什么呢？如何实现？

#### 过程：

- 首先创建了一个新的空对象
- 设置原型，将对象的原型设置为函数的 prototype 对象。
- 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

#### 实现：

```js
function objectFactory() {
  let newObject = null,
    constructor = Array.prototype.shift.call(arguments),
    result = null;

  // 参数判断
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }

  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);

  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);

  // 判断返回对象
  let flag =
    result && (typeof result === "object" || typeof result === "function");

  // 判断返回结果
  return flag ? result : newObject;
}

// 使用方法
// objectFactory(构造函数, 初始化参数);
```

# javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？

#### use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。

#### 设立"严格模式"的目的，主要有以下几个：

- 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

#### 区别：

- 禁止使用 with 语句。
- 禁止 this 关键字指向全局对象。
- 对象不能有重名的属性。

#### 回答：

#### use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。

# 什么是 Promise 对象，什么是 Promises/A+ 规范？

### Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。

### Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

# cookie，sessionStorage 和 sessionStorage 的联系和区别

# for in 和 for of 的区别

```md
# for... in ...:主要用来遍历对象中可枚举(enumerable 值为 true)的属性，包括原型链上可继承的属性，一般用来遍历对象，如果是数组的话，for...in 循环有几个缺点。

- 数组的键名是数字，但是 for...in 循环是以字符串作为键名“0”、“1”、“2”等等。
- for...in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，for...in 循环会以任意顺序遍历键名。

# 所以遍历数组一般用数组自己的方法，map()或者 forEach()
```

```md
# for...of...用来遍历可迭代的数据结构：（不可以遍历对象）

# 可迭代：部署了 Symbol.iterator 属性的数据结构，凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了迭代器接口。调用这个接口，就会返回一个迭代器对象。该对象的根本特征就是具有 next 方法。每次调用 next 方法，都会返回一个代表当前成员的信息对象，具有 value 和 done 两个属性。

原生具备 Iterator 接口的数据结构如下：

- Array
- String
- Map
- Set
- TypedArray（类数组）：函数的 arguments 对象和 NodeList 对象
- Generator 对象
```

# 什么是类数组
#### 类数组是 JavaScript 中一种特殊的对象。它们表现出非常类似数组的特征，但由于它们不适合使用标准 array 方法，因此可以说它们不是真正的数组。类数组具有 “length” 属性，并且可以使用索引来访问各个元素。例如：DOM NodeLists 和 arguments 变量都可以认为是类数组。但是由于它们不使用 Array.prototype上的方法，因此无法使用常见的数组方法，例如 map()、forEach()、push() 等。
#### 使用 Array.from()，Array.prototype.slice.call()将类数组转化为数组

# 遍历对象和数组

# 数组的常用方法以及返回值

# 深拷贝与浅拷贝的理解以及怎么实现？

```md
# 浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（新旧对象共享同一块内存），所以如果其中一个对象改变了这个地址，就会影响到另一个对象（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构 2 次，即 delete 同一块内存 2 次，造成程序崩溃）
```

```md
# 深拷贝： 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存）,且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）
```

## 实现方式：

### 浅拷贝：

#### 数组：

- slice 和 concat 方法
- Array.from()
- 扩展运算符

#### 对象：

- Object.assign
- 扩展运算符

### 深拷贝：

- JSON.parse(JSON.stringify(object)),缺点：会忽略 undefined、symbol 和函数，因为他们不能序列化
- 手写递归实现
- lodash 的-.cloneDeep()方法
- window.structuredClone()方法

#### 数组：

- 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。

- 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。

# 跨域

# js 延迟加载的方式有哪些？

# ES6 新特性

- “class“
- "let 和 const"
- “箭头函数“
- “解构赋值“
- “字符串模板“
- “promise“
- “async/await“（es7）
- “引入 module 模块“
- "Iterator"和 for...of...
- “generators(生成器)“
- “symbol“
- "Map 和 Set"
- "Proxy"和"Reflect"

# 三种事件模型是什么？

#### 事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

- 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

- 第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

- 第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

# 事件委托是什么？

#### 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

#### 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

# Vue2 和 3 的区别

- options Api and Composition Api
- 数据响应式的原理变化：
  - Vue2：使用 Object.defineProperty 对 data 中的数据实现数据劫持(缺点，不能侦测到对象属性的增加与删除，需要另外的 API 以及不能对数组的数据进行数据劫持，需要通过重写数组方法来实现)
  - Vue3：使用 Proxy 与 Reflect 实现数据的响应式，因为 Proxy 可以直接监听对象和数组的变化
- 生命周期的变化：Vue3 中的生命周期相对于 Vue2 做了一些调整，命名上发生了一些变化并且移除了 beforeCreate 和 created，因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不再需要它们。
- v-if 与 v-for 优先级的变化：Vue2 v-for 优先级高，Vue3 v-if 优先级高
- 路由:在 setup 里面没有访问 this，所以不能再直接访问 this.$router 或 this.$route。作为替代，我们使用 useRouter 和 useRoute 函数：
  const router = useRouter()
  const route = useRoute()

# MVC 和 MVVM 模式的特点与区别

```md
# MVC:Model 代表数据存储，主要用于实现数据的持久化；View 代表用户界面(UI)，主要用于实现页面的显示；Controller 代表业务逻辑，串联起 View 和 Model，主要用来实现业务的逻辑代码。在 MVC 模式中，用户的交互行为在 View 中触发，由 View 通知 Controller 去进行对应的逻辑处理，处理完成之后通知 Model 改变状态，Model 完成状态改变后，找到对应的 View 去更新用户界面的显示内容，至此完成对用户交互行为的反馈。由此可见，整个流程由 View 发起，最终在 View 中做出改变，这是一个单向的过程。当年流行的 backbone.js 就是 MVC 的典型代表。
```

```md
# MVVM:MVVM 是把 MVC 中的 Controller 去除了，相当于变薄了，取而代之的是 ViewModel。所谓 ViewModel，是一个同步的 View 和 Model 的对象，在前端 MVVM 中，ViewModel 最典型的作用是操作 DOM，特点是双向数据绑定(Data-Binding)。在双向数据绑定中，开发者无须关注如何找到 DOM 节点和如何修改 DOM 节点，因为每一个在 View 中需要操作的 DOM 都会有一个在 Model 中对应的对象，通过改变这个对象，DOM 就会自动改变；反之，当 DOM 改变时，对应的 Model 中的对象也会改变。ViewModel 将 View 和 Model 关联起来，因此开发者只需关注业务逻辑，不需要手动操作 DOM，这就是 ViewModel 带来的优势
```

# Vue 响应式原理

# Vue 组件间通信的方式

- 父传子：props ,子传父：自定义事件 emit
- provide 与 inject
- 事件总线
- vue 的全局状态管理器：Vuex 与 pinia(区别)
- 在父组件使用 ref 获取子组件实例

# Vue diff 算法

#### diff 算法的作用：diff 算法是用来计算两组子节点的差异，并试图最大程度地复用 DOM 元素。

- 最原始的方法更新子节点：卸载所有的旧子节点，再挂载所有的新子节点。这种更新方式无法对 DOM 元素进行复用，需要大量的 DOM 操作才能完成更新，非常消耗性能。于是改进：遍历新旧两组子节点中数量较少的那一组，并逐个调用 patch 函数进行打补丁，然后比较新旧两组子节点的数量，如果新的一组的子节点数更多，说明有新子节点需要挂载；否则就说明在旧的一组子节点中，有节点需要卸载。
- key 的作用：key 值就像是虚拟节点的“身份证号”，只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作）。在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。所以我们就需要知道如何寻找需要移动的节点

- 简单 diff 算法：
  - 找到可复用的 DOM 进行更新：只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作），两层 for 循环，外层循环遍历新的一组子节点，内层循环遍历旧的一组子节点。在内层循环中，逐个对比新旧子节点的 key 值，如果在旧子节点中找到可复用的节点，则调用 patch 函数进行打补丁。这样就可以保证所有可复用的节点本身都已经更新完毕了。
  - 找到需要移动的元素：(最大索引：在旧子节点中寻找具有相同 key 值节点的过程中，遇到的最大索引值)，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引，把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引(不需要更新的情况是最大索引值递增)，则说明该节点对应的真实 DOM 元素需要移动(移动之前需要用 patch 函数进行打补丁)
  - 如何移动节点：移动节点是指：移动一个虚拟节点所对应的真是 DOM 节点，并不是移动虚拟节点本身，所以得获得真实 DOM 节点的引用，即 vnode.el 属性。在更新操作时，渲染器会调用 patchElement 函数在新旧虚拟节点之间打补丁，在函数内部有一个赋值语句：const el = n2.el = n1.el(nl:旧虚拟节点，n2:新虚拟节点)，所以复用了 DOM 元素之后，新节点也持有了对真实 DOM 的引用。所以在整个更新过程中，当找到的索引值小于最大索引值的时候，获取当前新子节点的前一个节点，如果该前驱节点不存在，说明该新子节点是第一个节点，不需要移动，否则，获取该前驱节点对应真实 DOM 的下一个兄弟节点，将其作为锚点，然后用 insert 方法将该新子节点对应的真实 DOM 插入到锚点元素前面，也就是前驱节点对应真实节点的后面，insert 方法内部依赖了浏览器原生的 insertBefore 方法
  - 如何新增节点：首先，在外层循环定义一个 find 变量，代表渲染器是否能在旧的一组子节点中找到可复用的节点。变量 find 的初始值为 false，一道寻找到可复用的节点，则将变量 find 的值设置为 true。如果内层循环结束后，变量 find 的值仍为 false，则说明当前的新虚拟节点是一个全新的节点，需要挂载它。为了将节点挂载到正确位置，我们需要先获取锚点元素，找到当前新虚拟节点的前驱节点，如果存在，则使用它对应的真实 DOM 的下一个兄弟节点作为锚点元素；如果不存在，则说明将挂载的新虚拟节点是容器元素的第一个子节点，此时应该使用容器元素的 container.firstChild 作为锚点元素。最后，将锚点元素 anchor 作为 patch 函数的第四个参数，调用 patch 函数完成节点的挂载
  - 移除不存在的元素：当基本更新完成之后，再遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同 key 值的节点。如果找不到，说明应该删除该节点，用 unmount 函数将其卸载
- 双端 diff 算法：
  - 同时对新旧两组子节点的两个端点进行比较，获取新旧两端子节点的索引值，再获取对应的节点，然后依次比较旧头新头，旧尾新尾，旧头新尾和旧尾新头节点的 key 值是否向相同；
    - 理想情况：如果相同，则先用 patch 函数进行更新，然后再进行 DOM 元素的移动，最后在对当前索引值进行更新，向各自正确的方向前进一步，并指向下一个节点，循环的终止条件时任意一个头节点的索引值大于对应尾节点的索引值；
    - 非理想情况：如果经过比较之后，都没有可以复用的节点，需要增加额外的处理步骤来处理：拿新的一组子节点中的头部节点去旧的一组子节点中寻找是否有 key 值相同的节点。假设在旧子节点组中索引为 1 的位置上找到了可以复用的节点，意味着这个节点在新节点中并不是头部节点，但是在更新之后，变成了头部节点，所以需要将该节点对应的真实 DOM 移动到当前旧的一组子节点的头部节点所对应的真实 DOM 节点之前(移动操作之前还需打补丁)，由于该索引值对应的真实 DOM 已经移动到别处，将其设置为 undefined，然后再更新新头部节点的索引值继续比较，所以我们可以再循环的逻辑再加一层，旧子节点的头部和尾部节点是否存在，如果不存在则证明它们已经被处理过了，直接跳下一个位置即可。
    - 添加新元素：当我们在第一轮比较中没有找到可复用的节点，然后拿新的一组子节点中的头部节点去旧的一组子节点中寻找，也没找到可复用的节点，所以我们要在循环结束后检查索引值的情况，当旧尾索引值小于旧头索引值，且新头索引值小于等于新尾索引值，就说明有新的节点遗漏，需要挂载它们，于是增加一个 for 循环来挂载索引值位于新头和新尾之间的新节点。挂载时的锚点仍然使用当前的头部节点 oldStartVNode.el
    - 移除不存在的元素，与处理新节点类似，在 while 循环结束后加入一个 else if 的分支，当新尾索引值小于新头索引值，且旧头索引值小于等于旧尾索引值，，需要增加一个 for 循环来卸载索引值位于旧头和旧尾之间的旧节点。
  - 优势：减少 DOM 移动操作的次数

# vue 中 key 值的作用？

#### key 值就像是虚拟节点的“身份证号”，只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作）。在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。

# computed 和 watch 的差异？

- computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。

- computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。

- 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。

# 观察者和发布订阅模式的区别

### 发布订阅模式实际上是广义上的观察者模式：发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式

#### 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件之后，直接接收事件并作出响应

#### 在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者之间关系的解耦。使用发布订阅模式更利于我们代码的可维护性。

# Vue 的生命周期

## Vue2：

- beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问
- created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom
- beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。
- mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点
- beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
- updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。
- beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。
- destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
- activated keep-alive 专属，组件被激活时调用
- deactivated keep-alive 专属，组件被销毁时调用

```md
# 常见面试题：异步请求在哪一步发起？

# 可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
```

```md
# vue 可不可以在 created 钩子操作 dom

# 使用 nextTick,将 dom 操作放在回调函数里
```

# vue 路由跳转的原理

```md
# hash 模式：地址栏带#符号，每次哈希值变化都会调用 hashChange 事件。优点：兼容性好，刷新不会重新加载页面。缺点：不美观

# history 模式：利用的是 HTML5 新增的 pushState()和 replaceState()方法，push 会留下历史记录，replace 不会留下历史记录。优点：美观；缺点：兼容性，刷新会 404，需要后端配置，例如 Nginx 配置 try_files，
```

# v-model 的原理

```md
# 文本类型的 <input> 和 <textarea> 元素会绑定 value property 并侦听 input 事件；

# <input type="checkbox"> 和 <input type="radio"> 会绑定 checked property 并侦听 change 事件；

# <select> 会绑定 value property 并侦听 change 事件。
```

# H5 新特性

- 语义化标签
- 音视频标签
- input 标签的 type 值（email,tel,search）
- input 新增表单属性(required,placeholder,autofocus,autocomplete,multiple)

# 简述一下你对 HTML 语义化的理解？

#### html 语义化主要指的是开发者应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big，font 这些没有语义的标签。

# C3 新特性

- 属性选择器 div[type = xxx]
- 结构伪类选择器 E:first-child,last-child,nth-child(n)
- 伪元素选择器

# CSS 中常用的单位

- em：有继承性，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width，height，padding
- rem：根元素的字体大小
- vw：视窗宽度的 1%
- vh：视窗高度的 1%

# BFC

```md
块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。
```

#### 通俗来讲

- BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。
- 如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。

#### 解决什么问题：

- 解决浮动元素使父元素高度塌陷
- 外边距重叠（为其中一个元素的外边包裹一层父元素，并且触发父元素 BFC）
- 浮动元素重叠（解决自适应布局的问题）：PC 端的网页，左右两栏布局很常见，一般左侧定宽，右侧主体页面宽度自适应变化，通常是用浮动来实现的；它利用了块级元素占满一行的特性，使得右边的元素可以随着页面宽度的变化而变化，又利用了浮动的特性，让左侧元素覆盖在右侧元素上方，同时还能挤开下方元素的内容，让页面看起来是两栏的效果，但随着右边元素的增加，超出了左边元素的高度后，文字就会环绕左侧元素，这显然不是我们想要的效果，因为右侧元素触发了 BFC，触发 BFC 的容器就是页面上的一个完全隔离开的容器，容器中的子元素绝对不会影响到外面的元素，为了保证这个规则，触发了 BFC 的右侧元素为了将内部元素和左侧浮动元素隔离开，不得不形成这样左右完全隔离的两栏，同时，如果右侧元素依旧是块级元素，那么他尽可能占满一行的特性还在，这样就保证了右侧元素依旧是自适应的

#### 怎么触发 BFC：

- 根元素（html），或者包含 body 的元素
- overflow 的值为非 visible（hidden，auto，scroll）
- display 的值为:inline-block,flow-root（无副作用但是不兼容 IE）,grid,flex,table,table-cell
- position 的值为:fixed 或者 absolute
- float 的值不为 none（left 或者 right）

# link 和 @import 的区别

- link 是 HTML 标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；@import 是 CSS 提供的语法，只有导入样式表的作用。
- 加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。
- @import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。
- 可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import 的方式插入样式。
- link 引入的样式权重大于@import 引入的样式。

# position 属性

- static 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom,left,right,z-index 声明）

- relative 生成相对定位的元素，不影响元素本身特性， 不会使元素脱离文档流， 没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移），提升层级（用 z-index 样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面，z-index 只能在 position 属性值为 relative 或 absolute 或 fixed 的元素上有效。） （两个都为定位元素，后面的会覆盖前面的定位）

- absolute 生成绝对定位的元素， 使元素完全脱离文档流（在文档流中不再占位），使内联元素在设置宽高的时候支持宽高，使区块元素在未设置宽度时由内容撑开宽度，相对于最近一个有定位的父元素偏移（若其父元素没有定位则逐层上找，直到 document——页面文档对象），相对定位一般配合绝对定位使用，提升层级
- fixed（老 IE 不支持）生成绝对定位的元素，相对于浏览器窗口进行定位

- sticky 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

# 如何垂直和水平居中

```md
一般常见的几种居中的方法有：

对于宽高固定的元素

（1）我们可以利用 margin:0 auto 来实现元素的水平居中。

（2）利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水
平和垂直方向上的居中。

（3）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素
的中心点到页面的中心。

（4）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素
的中心点到页面的中心。

（5）使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对
齐，然后它的子元素也可以实现垂直和水平的居中。

对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。
```

# CSS 选择器

- id 选择器（#myid）
- 类选择器（.myclassname）
- 标签选择器（div,h1,p）
- 后代选择器（h1 p）
- 相邻后代选择器（子）选择器（ul>li）
- 兄弟选择器（li~a）
- 相邻兄弟选择器（li+a）
- 属性选择器（a[rel="external"]）
- 伪类选择器（a:hover,li:nth-child）
- 伪元素选择器（::before、::after）
- 通配符选择器（\*）

# 画一个三角形

#### 采用的是相邻边框连接处的均分原理。

```css
将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。
  #demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```
# CSS Modules是什么
CSS Modules 是一种 CSS 方案，用于在模块化的 JavaScript 应用程序中管理样式。它通过在编译时为每个类名生成唯一的哈希字符串来实现样式的封装，从而使每个模块的样式独立于其他模块。

使用 CSS Modules 可以解决样式命名冲突的问题，并且可以通过在 JavaScript 中直接引用类名来实现样式的复用。

例如，假设您有一个名为 button.css 的样式文件，其中包含以下样式：
```css
.button {
  background-color: blue;
  color: white;
  font-size: 16px;
  padding: 10px 20px;
  border-radius: 4px;
}

```
使用 CSS Modules，您可以在 JavaScript 文件中通过以下方式引用这些样式：
```js
import styles from './button.css';

const button = document.createElement('button');
button.className = styles.button;
```
在这种情况下，.button 类名将会被编译成一个唯一的哈希字符串，并自动添加到 styles 对象的 button 属性上。这样，您就可以通过引用 `styles.button` 来使用这些样式，而不必担心命名冲突的问题。

使用 CSS Modules 还有一个好处是，它可以让您在编写样式时更方便地使用 JavaScript 变量。例如，您可以在样式文件中使用 :export 关键字来导出 JavaScript 变量，并在 JavaScript 中通过 import 语句引用这些变量。
```css
:export {
  primaryColor: blue;
  secondaryColor: green;
}

.button {
  color: primaryColor;
}

```
在 JavaScript 文件中，您可以通过以下方式引用这些样式：
```js
import { primaryColor, secondaryColor } from './colors.css';

const button = document.createElement('button');
button.style.color = primaryColor;
```
CSS Modules 可以通过使用 Webpack 或其他构建工具来实现，并且可以与 React、Vue.js 等框架很好地配合使用。它是一种很好的解决方案，可以让您在模块化的应用程序中更好地管理样式。
# DOMContentLoaded 事件和 Load 事件的区别？

- 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。

- Load 事件是当所有资源加载完成后触发的。

# xss 和 csrf 是什么，如何防范

```md
# XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

## XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

#### XSS 一般分为存储型、反射型和 DOM 型。

- 存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。

- 反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。

- DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。

## XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

- 对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的.因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

- 还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

- 还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
```

```md
# CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

## CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

#### 一般的 CSRF 攻击类型有三种：

- 第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提
  交。

- 第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。

- 第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

#### CSRF 可以用下面几种方法来防护：

- 第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

- 第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

- 第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

- 第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。
```
## 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

# 开发中常用的几种 Content-Type ？

- application/x-www-form-urlencoded

浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL
转码。

- multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

- application/json

告诉服务器消息主体是序列化后的 JSON 字符串。

- text/xml

该种方式主要用来提交 XML 格式的数据。
# Get和Post方法的区别
GET 和 POST 是 HTTP 协议中两种不同的请求方法，它们被用于从 Web 服务器获取数据或向服务器发送数据。

GET 请求是一种幂等的请求方法，这意味着多次执行 GET 请求对服务器没有影响。因此，GET 请求通常用于获取数据，而不是修改数据。

POST 请求则不同，它是非幂等的，意味着多次执行 POST 请求可能会对服务器造成影响。因此，POST 请求通常用于提交数据，例如提交表单数据或上传文件。

两种请求方法还有一些其他差异：

- GET 请求的参数通常包含在 URL 中，而 POST 请求的参数通常包含在请求正文中。

- GET 请求参数会被浏览器保存在历史记录中，而 POST 请求参数不会被保存。

- GET 请求的参数长度是有限制的（通常为 2KB 到 8KB），而 POST 请求的参数长度没有限制。

- GET 请求可以被缓存，而 POST 请求不能被缓存。

总的来说，GET 请求适用于获取数据，而 POST 请求适用于提交数据。
# eval 是做什么的？

#### 它的功能是把对应的字符串解析成 JS 代码并运行。

#### 应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。

# 浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来的流程 ：

- 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）
- 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）
- 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）
- 进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置
- 进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来

# 事件委托：

```md
# 事件委托是利用事件流的特征解决一些开发需求的知识技巧

# 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

# 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
```

# DNS 完整的查询过程:

- 首先会在「浏览器的缓存」中查找对应的 IP 地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给「本地 DNS 服务器」，在本地 DNS 服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地 DNS 服务器向「根域名服务器」发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地 DNS 服务器向「顶级域名服务器」发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地 DNS 服务器向「权威域名服务器」发送请求，域名服务器返回对应的结果
- 本地 DNS 服务器将返回结果保存在缓存中，便于下次使用
- 本地 DNS 服务器将返回结果返回给浏览器

### 递归查询和迭代查询

```md
# 递归查询:指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。

# 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
```

```md
# 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。
```

# 代码输出题

```js
setTimeout(() => {
  console.log("setTimeout start"); //5
  new Promise((resolve) => {
    console.log("promise1 start"); //6
    resolve();
  }).then(() => {
    console.log("promise1 end"); //8
  });
  console.log("setTimeout end"); //7
}, 0);
function promise2() {
  return new Promise((resolve) => {
    console.log("promise2"); //2
    resolve();
  });
}
async function async1() {
  console.log("async1 start"); //1
  await promise2();
  console.log("async1 end"); //4
}
async1();
console.log("script end"); //3
//函数不调用不执行，async是同步，new Promise是同步，await下一行的代码是异步微任务
```
