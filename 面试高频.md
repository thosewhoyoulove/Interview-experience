<!--
 * @Description:
 * @Author: 曹俊
 * @Date: 2022-11-11 20:23:31
 * @LastEditors: 曹俊
 * @LastEditTime: 2022-12-01 20:40:42
-->

# 自我介绍

# js 数据类型以及存放位置

# js 判断数据类型的方法

# js 事件循环机制

## 事件循环机制：

- js 是单线程，为了防止代码阻塞，把任务分为：同步和异步任务
- 同步代码交给 js 引擎执行，异步代码交给宿主环境(node 或者浏览器)
- 同步代码放入执行栈中，异步代码等待特殊时机(比如定时器倒计时完成，点击按钮触发回调函数)送入到任务队列（分为微任务队列和宏任务队列）
- 先执行执行栈中的同步任务，由于微任务比宏任务先执行，就会先去查看微任务队列中是否有微任务，如果有就执行，没有就查看宏任务队列，有就执行，没有就继续查看微任务队列，反复循环，这个过程就是事件循环

# this 的指向

- 作为普通函数调用，this 指向 window
- 作为对象的方法调用，this 指向这个对象
- 使用 new 关键字对构造函数进行实例化，this 指向实例化的对象
- 箭头函数没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。
- 使用 call(),apply(),bind(),this 绑定这些方法的第一个参数
- 严格模式下，this 默认为 undefined
- setTimeout()的回调函数里面的 this 默认 指向 window 对象，所以用箭头函数可以直接获取到上下文的 this，可以不用变量保存 this

# 闭包

# 原型和原型链

# 作用域和作用域链

# var，let 和 const 的区别

# js 继承

# new 操作符具体干了什么呢？如何实现？

#### 过程：

- 首先创建了一个新的空对象
- 设置原型，将对象的原型设置为函数的 prototype 对象。
- 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

#### 实现：

```js
function objectFactory() {
  let newObject = null,
    constructor = Array.prototype.shift.call(arguments),
    result = null;

  // 参数判断
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }

  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);

  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);

  // 判断返回对象
  let flag =
    result && (typeof result === "object" || typeof result === "function");

  // 判断返回结果
  return flag ? result : newObject;
}

// 使用方法
// objectFactory(构造函数, 初始化参数);
```

# javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？

#### use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。

#### 设立"严格模式"的目的，主要有以下几个：

- 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

#### 区别：

- 禁止使用 with 语句。
- 禁止 this 关键字指向全局对象。
- 对象不能有重名的属性。

#### 回答：

#### use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。

# 什么是 Promise 对象，什么是 Promises/A+ 规范？

### Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。

### Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

# cookie，sessionStorage 和 sessionStorage 的联系和区别

# for in 和 for of 的区别

```md
# for... in ...:主要用来遍历对象中可枚举(enumerable 值为 true)的属性，包括原型链上可继承的属性，一般用来遍历对象，如果是数组的话，for...in 循环有几个缺点。

- 数组的键名是数字，但是 for...in 循环是以字符串作为键名“0”、“1”、“2”等等。
- for...in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，for...in 循环会以任意顺序遍历键名。

# 所以遍历数组一般用数组自己的方法，map()或者 forEach()
```

```md
# for...of...用来遍历可迭代的数据结构：（不可以遍历对象）

# 可迭代：部署了 Symbol.iterator 属性的数据结构，凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了迭代器接口。调用这个接口，就会返回一个迭代器对象。该对象的根本特征就是具有 next 方法。每次调用 next 方法，都会返回一个代表当前成员的信息对象，具有 value 和 done 两个属性。

原生具备 Iterator 接口的数据结构如下：

- Array
- String
- Map
- Set
- TypedArray（类数组）：函数的 arguments 对象和 NodeList 对象
- Generator 对象
```

# 遍历对象和数组

# 数组的常用方法以及返回值

# 深拷贝与浅拷贝的理解以及怎么实现？

```md
# 浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址（新旧对象共享同一块内存），所以如果其中一个对象改变了这个地址，就会影响到另一个对象（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构 2 次，即 delete 同一块内存 2 次，造成程序崩溃）
```

```md
# 深拷贝： 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存）,且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）
```

## 实现方式：

### 浅拷贝：

#### 数组：

- slice 和 concat 方法
- Array.from()
- 扩展运算符

#### 对象：

- Object.assign
- 扩展运算符

### 深拷贝：

- JSON.parse(JSON.stringify(object)),缺点：会忽略 undefined、symbol 和函数，因为他们不能序列化
- 手写递归实现
- lodash 的-.cloneDeep()方法
- window.structuredClone()方法

#### 数组：

- 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。

- 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。

# 跨域

# js 延迟加载的方式有哪些？

# ES6 新特性

- “class“
- "let 和 const"
- “箭头函数“
- “解构赋值“
- “字符串模板“
- “promise“
- “async/await“（es7）
- “引入 module 模块“
- "Iterator"和 for...of...
- “generators(生成器)“
- “symbol“
- "Map 和 Set"
- "Proxy"和"Reflect"

# 三种事件模型是什么？

#### 事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

- 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

- 第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

- 第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

# 事件委托是什么？

#### 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

#### 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

# Vue2 和 3 的区别

# MVC 和 MVVM 模式的特点与区别

```md
# MVC:Model 代表数据存储，主要用于实现数据的持久化；View 代表用户界面(UI)，主要用于实现页面的显示；Controller 代表业务逻辑，串联起 View 和 Model，主要用来实现业务的逻辑代码。在 MVC 模式中，用户的交互行为在 View 中触发，由 View 通知 Controller 去进行对应的逻辑处理，处理完成之后通知 Model 改变状态，Model 完成状态改变后，找到对应的 View 去更新用户界面的显示内容，至此完成对用户交互行为的反馈。由此可见，整个流程由 View 发起，最终在 View 中做出改变，这是一个单向的过程。当年流行的 backbone.js 就是 MVC 的典型代表。
```

```md
# MVVM:MVVM 是把 MVC 中的 Controller 去除了，相当于变薄了，取而代之的是 ViewModel。所谓 ViewModel，是一个同步的 View 和 Model 的对象，在前端 MVVM 中，ViewModel 最典型的作用是操作 DOM，特点是双向数据绑定(Data-Binding)。在双向数据绑定中，开发者无须关注如何找到 DOM 节点和如何修改 DOM 节点，因为每一个在 View 中需要操作的 DOM 都会有一个在 Model 中对应的对象，通过改变这个对象，DOM 就会自动改变；反之，当 DOM 改变时，对应的 Model 中的对象也会改变。ViewModel 将 View 和 Model 关联起来，因此开发者只需关注业务逻辑，不需要手动操作 DOM，这就是 ViewModel 带来的优势
```

# Vue 响应式原理

# Vue 组件间通信的方式

# Vue diff 算法

#### diff 算法的作用：diff 算法是用来计算两组子节点的差异，并试图最大程度地复用 DOM 元素。

- 最原始的方法更新子节点：卸载所有的旧子节点，再挂载所有的新子节点。这种更新方式无法对 DOM 元素进行复用，需要大量的 DOM 操作才能完成更新，非常消耗性能。于是改进：遍历新旧两组子节点中数量较少的那一组，并逐个调用 patch 函数进行打补丁，然后比较新旧两组子节点的数量，如果新的一组的子节点数更多，说明有新子节点需要挂载；否则就说明在旧的一组子节点中，有节点需要卸载。
- key 的作用：key 值就像是虚拟节点的“身份证号”，只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作）。在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。所以我们就需要知道如何寻找需要移动的节点

- 简单 diff 算法：
  - 找到可复用的 DOM 进行更新：只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作），两层 for 循环，外层循环遍历新的一组子节点，内层循环遍历旧的一组子节点。在内层循环中，逐个对比新旧子节点的 key 值，如果在旧子节点中找到可复用的节点，则调用 patch 函数进行打补丁。这样就可以保证所有可复用的节点本身都已经更新完毕了。
  - 找到需要移动的元素：(最大索引：在旧子节点中寻找具有相同 key 值节点的过程中，遇到的最大索引值)，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引，把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引(不需要更新的情况是最大索引值递增)，则说明该节点对应的真实 DOM 元素需要移动(移动之前需要用 patch 函数进行打补丁)
  - 如何移动节点：移动节点是指：移动一个虚拟节点所对应的真是 DOM 节点，并不是移动虚拟节点本身，所以得获得真实 DOM 节点的引用，即 vnode.el 属性。在更新操作时，渲染器会调用 patchElement 函数在新旧虚拟节点之间打补丁，在函数内部有一个赋值语句：const el = n2.el = n1.el(nl:旧虚拟节点，n2:新虚拟节点)，所以复用了 DOM 元素之后，新节点也持有了对真实 DOM 的引用。所以在整个更新过程中，当找到的索引值小于最大索引值的时候，获取当前新子节点的前一个节点，如果该前驱节点不存在，说明该新子节点是第一个节点，不需要移动，否则，获取该前驱节点对应真实接 DOM 的下一个兄弟节点，将其作为锚点，然后用 insert 方法将该新子节点对应的真实 DOM 插入到锚点元素前面，也就是前驱节点对应真实节点的后面，insert 方法内部依赖了浏览器原生的 insertBefore 方法
  - 如何新增节点：首先，在外层循环定义一个 find 变量，代表渲染器是否能在旧的一组子节点中找到可复用的节点。变量 find 的初始值为 false，一道寻找到可复用的节点，则将变量 find 的值设置为 true。如果内层循环结束后，变量 find 的值仍为 false，则说明当前的新虚拟节点是一个全新的节点，需要挂载它。为了将节点挂载到正确位置，我们需要先获取锚点元素，找到当前新虚拟节点的前驱节点，如果存在，则使用它对应的真实 DOM 的下一个兄弟节点作为锚点元素；如果不存在，则说明将挂载的新虚拟节点是容器元素的第一个子节点，此时应该使用容器元素的 container.firstChild 作为锚点元素。最后，将锚点元素 anchor 作为 patch 函数的第四个参数，调用 patch 函数完成节点的挂载
  - 移除不存在的元素：当基本更新完成之后，再遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同 key 值的节点。如果找不到，说明应该删除该节点，用 unmount 函数将其卸载

# vue 中 key 值的作用？

#### key 值就像是虚拟节点的“身份证号”，只要两个虚拟节点的 type 值和 key 值都相同，那么就可以进行 DOM 节点的复用（可以复用不一定不需要更新，仍需要对两个虚拟节点进行打补丁操作）。在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。

# computed 和 watch 的差异？

- computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。

- computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。

- 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。

# 观察者和发布订阅模式的区别

### 发布订阅模式实际上是广义上的观察者模式：发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式

#### 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件之后，直接接收事件并作出响应

#### 在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者之间关系的解耦。使用发布订阅模式更利于我们代码的可维护性。

# Vue 的生命周期

## Vue2：

- beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问
- created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom
- beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。
- mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点
- beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
- updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。
- beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。
- destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
- activated keep-alive 专属，组件被激活时调用
- deactivated keep-alive 专属，组件被销毁时调用

```md
# 常见面试题：异步请求在哪一步发起？

# 可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
```

```md
# vue 可不可以在 created 钩子操作 dom

# 使用 nextTick,将 dom 操作放在回调函数里
```

# vue 路由跳转的原理

```md
# hash 模式：地址栏带#符号，每次哈希值变化都会调用 hashChange 事件。优点：兼容性好，刷新不会重新加载页面。缺点：不美观

# history 模式：利用的是 HTML5 新增的 pushState()和 replaceState()方法，push 会留下历史记录，replace 不会留下历史记录。优点：美观；缺点：兼容性，刷新会 404，需要后端配置，例如 Nginx 配置 try_files，
```

# v-model 的原理

```md
# 文本类型的 <input> 和 <textarea> 元素会绑定 value property 并侦听 input 事件；

# <input type="checkbox"> 和 <input type="radio"> 会绑定 checked property 并侦听 change 事件；

# <select> 会绑定 value property 并侦听 change 事件。
```

# H5 新特性

- 语义化标签
- 音视频标签
- input 标签的 type 值（email,tel,search）
- input 新增表单属性(required,placeholder,autofocus,autocomplete,multiple)

# C3 新特性

- 属性选择器 div[type = xxx]
- 结构伪类选择器 E:first-child,last-child,nth-child(n)
- 伪元素选择器

# CSS 中常用的单位

- em：有继承性，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width，height，padding
- rem：根元素的字体大小
- vw：视窗宽度的 1%
- vh：视窗高度的 1%

# BFC

```md
块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。
```

#### 通俗来讲

- BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。
- 如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。

#### 解决什么问题：

- 解决浮动元素使父元素高度塌陷
- 外边距重叠（为其中一个元素的外边包裹一层父元素，并且触发父元素 BFC）
- 浮动元素重叠（解决自适应布局的问题）：PC 端的网页，左右两栏布局很常见，一般左侧定宽，右侧主体页面宽度自适应变化，通常是用浮动来实现的；它利用了块级元素占满一行的特性，使得右边的元素可以随着页面宽度的变化而变化，又利用了浮动的特性，让左侧元素覆盖在右侧元素上方，同时还能挤开下方元素的内容，让页面看起来是两栏的效果，但随着右边元素的增加，超出了左边元素的高度后，文字就会环绕左侧元素，这显然不是我们想要的效果，因为右侧元素触发了 BFC，触发 BFC 的容器就是页面上的一个完全隔离开的容器，容器中的子元素绝对不会影响到外面的元素，为了保证这个规则，触发了 BFC 的右侧元素为了将内部元素和左侧浮动元素隔离开，不得不形成这样左右完全隔离的两栏，同时，如果右侧元素依旧是块级元素，那么他尽可能占满一行的特性还在，这样就保证了右侧元素依旧是自适应的

#### 怎么触发 BFC：

- 根元素（html），或者包含 body 的元素
- overflow 的值为非 visible（hidden，auto，scroll）
- display 的值为:inline-block,flow-root（无副作用但是不兼容 IE）,grid,flex,table,table-cell
- position 的值为:fixed 或者 absolute
- float 的值不为 none（left 或者 right）

# link 和 @import 的区别

- link 是 HTML 标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；@import 是 CSS 提供的语法，只有导入样式表的作用。
- 加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。
- @import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。
- 可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import 的方式插入样式。
- link 引入的样式权重大于@import 引入的样式。

# position 属性

- static 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom,left,right,z-index 声明）

- relative 生成相对定位的元素，不影响元素本身特性， 不会使元素脱离文档流， 没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移），提升层级（用 z-index 样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面，z-index 只能在 position 属性值为 relative 或 absolute 或 fixed 的元素上有效。） （两个都为定位元素，后面的会覆盖前面的定位）

- absolute 生成绝对定位的元素， 使元素完全脱离文档流（在文档流中不再占位），使内联元素在设置宽高的时候支持宽高，使区块元素在未设置宽度时由内容撑开宽度，相对于最近一个有定位的父元素偏移（若其父元素没有定位则逐层上找，直到 document——页面文档对象），相对定位一般配合绝对定位使用，提升层级
- fixed（老 IE 不支持）生成绝对定位的元素，相对于浏览器窗口进行定位

- sticky 粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

# 如何垂直和水平居中

```md
一般常见的几种居中的方法有：

对于宽高固定的元素

（1）我们可以利用 margin:0 auto 来实现元素的水平居中。

（2）利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水
平和垂直方向上的居中。

（3）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素
的中心点到页面的中心。

（4）利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素
的中心点到页面的中心。

（5）使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对
齐，然后它的子元素也可以实现垂直和水平的居中。

对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。
```

# CSS 选择器

- id 选择器（#myid）
- 类选择器（.myclassname）
- 标签选择器（div,h1,p）
- 后代选择器（h1 p）
- 相邻后代选择器（子）选择器（ul>li）
- 兄弟选择器（li~a）
- 相邻兄弟选择器（li+a）
- 属性选择器（a[rel="external"]）
- 伪类选择器（a:hover,li:nth-child）
- 伪元素选择器（::before、::after）
- 通配符选择器（\*）

# 画一个三角形

#### 采用的是相邻边框连接处的均分原理。

```css
将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。
  #demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

# xss 和 csrf 是什么，如何防范

```md
# XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

## XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

#### XSS 一般分为存储型、反射型和 DOM 型。

- 存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。

- 反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。

- DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。

## XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

- 对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的.因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

- 还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

- 还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
```

```md
# CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

## CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

#### 一般的 CSRF 攻击类型有三种：

- 第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提
  交。

- 第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。

- 第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

#### CSRF 可以用下面几种方法来防护：

- 第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

- 第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

- 第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

- 第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。
```

# 开发中常用的几种 Content-Type ？

- application/x-www-form-urlencoded

浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL
转码。

- multipart/form-data

该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

- application/json

告诉服务器消息主体是序列化后的 JSON 字符串。

- text/xml

该种方式主要用来提交 XML 格式的数据。

# eval 是做什么的？

#### 它的功能是把对应的字符串解析成 JS 代码并运行。

#### 应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。

# 浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来的流程 ：

- 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）
- 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）
- 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）
- 进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置
- 进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来

# 事件委托：

```md
# 事件委托是利用事件流的特征解决一些开发需求的知识技巧

# 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

# 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
```

# DNS 完整的查询过程:

- 首先会在「浏览器的缓存」中查找对应的 IP 地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给「本地 DNS 服务器」，在本地 DNS 服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地 DNS 服务器向「根域名服务器」发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地 DNS 服务器向「顶级域名服务器」发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地 DNS 服务器向「权威域名服务器」发送请求，域名服务器返回对应的结果
- 本地 DNS 服务器将返回结果保存在缓存中，便于下次使用
- 本地 DNS 服务器将返回结果返回给浏览器

### 递归查询和迭代查询

```md
# 递归查询:指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。

# 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
```

```md
# 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。
```

# 代码输出题

```js
setTimeout(() => {
  console.log("setTimeout start"); //5
  new Promise((resolve) => {
    console.log("promise1 start"); //6
    resolve();
  }).then(() => {
    console.log("promise1 end"); //8
  });
  console.log("setTimeout end"); //7
}, 0);
function promise2() {
  return new Promise((resolve) => {
    console.log("promise2"); //2
    resolve();
  });
}
async function async1() {
  console.log("async1 start"); //1
  await promise2();
  console.log("async1 end"); //4
}
async1();
console.log("script end"); //3
//函数不调用不执行，async是同步，new Promise是同步，await下一行的代码是异步微任务
```
