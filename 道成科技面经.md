<!--
 * @Description:
 * @Author: 曹俊
 * @Date: 2022-11-07 16:45:13
 * @LastEditors: 曹俊
 * @LastEditTime: 2022-11-09 20:43:21
-->

# 项目

- 怎么封装 axios
- 项目的技术栈
- 文件路由是什么
- Vite 配置以及 vite 为什么这么快

# 八股

- Vue2 和 3 的区别
- Vue 父子组件的通信方式
- ES6 新特性（说说 proxy）
- H5 的新 API
- Promise
- 闭包
- this
- 原型和原型链
- 原型链继承和组合寄生式继承
- 数组去重
- Cookie，sessionStorage 和 localStorage
- 事件捕获和冒泡
- Keep—alive
- typescript 的掌握
- ES-module 以及 CommonJS
- 实现一个 ajax 请求的步骤
- CSS 的布局属性（详细说一下 sticky）
- 盒子垂直居中
- BFC 以及解决的问题
- CSS module
- CSS 预处理器
- git 从历史版本创建一个新分支

# 另外

- RFID 射频识别技术
- 传感器网络
- OS 间进程通信方式
- CDN 原理

# 为什么会有 CommonJs 和 Es Module 呢：

#### 我们都知道在早期 JavaScript 模块这一概念，都是通过 script 标签引入 js 文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的 js 文件就会越多，这时就会出现以下问题：

- js 文件作用域都是顶层，这会造成变量污染
- js 文件多，变得不好维护
- js 文件依赖问题，稍微不注意顺序引入错，代码全报错

#### 为了解决以上问题 JavaScript 社区出现了 CommonJs，CommonJs 是一种模块化的规范，包括现在的 NodeJs 里面也采用了部分 CommonJs 语法在里面。那么在后来 Es6 版本正式加入了 Es Module 模块，这两种都是解决上面问题，那么都是解决什么问题呢。

- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染
- 解决代码维护问题，一个文件里代码非常清晰
- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件

### CommonJs 基本语法:

#### 导出: CommonJs 中使用 module.exports 导出变量及函数，也可以导出任意类型的值，看如下案例。

```js
// 导出一个对象
module.exports = {
  name: "蛙人",
  age: 24,
  sex: "male",
};

// 导出任意值
module.exports.name = "蛙人";
module.exports.sex = null;
module.exports.age = undefined;
```

#### 直接导出:导出也可以省略 module 关键字，直接写 exports 导出也可以，看如下案例。

```js
exports.name = "蛙人";
exports.sex = "male";
```

#### 注意：如果使用 exports 导出单个值之后，就不能再导出一个同名的对象值，这只会修改 exports 的对象改变，然而修改无效，最终导出还是 name，和 sex，因为最终的导出是由 module.exports 决定的。

## CommonJs 和 Es Module 的区别

- CommonJs：
  - CommonJs 可以动态加载语句，代码发生在运行时
  - CommonJs 混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了
  - CommonJs 导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染
- Es Module：
  - Es Module 是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时
  - Es Module 混合导出，单个导出，默认导出，完全互不影响
  - Es Module 导出是引用值之前都存在映射关系，并且值都是可读的，不能修改

## 什么是 BFC

### Block formatting context(块级格式化上下文)：形成一个完全独立的空间，让空间中的子元素不会影响到外面的布局。

#### 解决什么问题：

- 解决浮动元素使父元素高度塌陷
- 外边距重叠（为其中一个元素的外边包裹一层父元素，并且触发父元素 BFC）
- 浮动元素重叠（解决自适应布局的问题）：PC 端的网页，左右两栏布局很常见，一般左侧定宽，右侧主体页面宽度自适应变化，通常是用浮动来实现的；它利用了块级元素占满一行的特性，使得右边的元素可以随着页面宽度的变化而变化，又利用了浮动的特性，让左侧元素覆盖在右侧元素上方，同时还能挤开下方元素的内容，让页面看起来是两栏的效果，但随着右边元素的增加，超出了左边元素的高度后，文字就会环绕左侧元素，这显然不是我们想要的效果，因为右侧元素触发了 BFC，触发 BFC 的容器就是页面上的一个完全隔离开的容器，容器中的子元素绝对不会影响到外面的元素，为了保证这个规则，触发了 BFC 的右侧元素为了将内部元素和左侧浮动元素隔离开，不得不形成这样左右完全隔离的两栏，同时，如果右侧元素依旧是块级元素，那么他尽可能占满一行的特性还在，这样就保证了右侧元素依旧是自适应的

#### 怎么触发 BFC：

- 根元素（html），或者包含 body 的元素
- overflow 的值为非 visible（hidden，auto，scroll）
- display 的值为:inline-block,flow-root,grid,flex,table,table-cell
- position 的值为:fixed 或者 absolute
- float 的值不为 none（left 或者 right）
