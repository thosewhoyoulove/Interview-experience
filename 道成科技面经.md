<!--
 * @Description:
 * @Author: 曹俊
 * @Date: 2022-11-07 16:45:13
 * @LastEditors: 曹俊
 * @LastEditTime: 2022-11-11 18:51:24
-->

# 项目

- 怎么封装 axios
- 项目的技术栈
- 文件路由是什么
- Vite 配置以及 vite 为什么这么快

# 八股

- Vue2 和 3 的区别
- Vue 父子组件的通信方式
- ES6 新特性（说说 proxy）
- H5 的新 API
- Promise
- 闭包
- this
- 原型和原型链
- 原型链继承和组合寄生式继承
- 数组去重
- Cookie，sessionStorage 和 localStorage
- 事件捕获和冒泡
- Keep—alive
- typescript 的掌握
- ES-module 以及 CommonJS
- 实现一个 ajax 请求的步骤
- CSS 的布局属性（详细说一下 sticky）
- 盒子垂直居中
- BFC 以及解决的问题
- CSS module
- CSS 预处理器
- git 从历史版本创建一个新分支

# 另外

- RFID 射频识别技术
- Linux
- 传感器网络
- OS 间进程通信方式
- CDN 原理

# 为什么会有 CommonJs 和 Es Module 呢：

#### 我们都知道在早期 JavaScript 模块这一概念，都是通过 script 标签引入 js 文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的 js 文件就会越多，这时就会出现以下问题：

- js 文件作用域都是顶层，这会造成变量污染
- js 文件多，变得不好维护
- js 文件依赖问题，稍微不注意顺序引入错，代码全报错

#### 为了解决以上问题 JavaScript 社区出现了 CommonJs，CommonJs 是一种模块化的规范，包括现在的 NodeJs 里面也采用了部分 CommonJs 语法在里面。那么在后来 Es6 版本正式加入了 Es Module 模块，这两种都是解决上面问题，那么都是解决什么问题呢。

- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染
- 解决代码维护问题，一个文件里代码非常清晰
- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件

### CommonJs 基本语法:

#### 导出: CommonJs 中使用 module.exports 导出变量及函数，也可以导出任意类型的值，看如下案例。

```js
// 导出一个对象
module.exports = {
  name: "蛙人",
  age: 24,
  sex: "male",
};

// 导出任意值
module.exports.name = "蛙人";
module.exports.sex = null;
module.exports.age = undefined;
```

#### 直接导出:导出也可以省略 module 关键字，直接写 exports 导出也可以，看如下案例。

```js
exports.name = "蛙人";
exports.sex = "male";
```

#### 注意：如果使用 exports 导出单个值之后，就不能再导出一个同名的对象值，这只会修改 exports 的对象改变，然而修改无效，最终导出还是 name，和 sex，因为最终的导出是由 module.exports 决定的。

## CommonJs 和 Es Module 的区别

- CommonJs：
  - CommonJs 可以动态加载语句，代码发生在运行时
  - CommonJs 混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了
  - CommonJs 导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染
- Es Module：
  - Es Module 是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时
  - Es Module 混合导出，单个导出，默认导出，完全互不影响
  - Es Module 导出是引用值之前都存在映射关系，并且值都是可读的，不能修改

## 什么是 BFC

### Block formatting context(块级格式化上下文)：形成一个完全独立的空间，让空间中的子元素不会影响到外面的布局。

#### 解决什么问题：

- 解决浮动元素使父元素高度塌陷
- 外边距重叠（为其中一个元素的外边包裹一层父元素，并且触发父元素 BFC）
- 浮动元素重叠（解决自适应布局的问题）：PC 端的网页，左右两栏布局很常见，一般左侧定宽，右侧主体页面宽度自适应变化，通常是用浮动来实现的；它利用了块级元素占满一行的特性，使得右边的元素可以随着页面宽度的变化而变化，又利用了浮动的特性，让左侧元素覆盖在右侧元素上方，同时还能挤开下方元素的内容，让页面看起来是两栏的效果，但随着右边元素的增加，超出了左边元素的高度后，文字就会环绕左侧元素，这显然不是我们想要的效果，因为右侧元素触发了 BFC，触发 BFC 的容器就是页面上的一个完全隔离开的容器，容器中的子元素绝对不会影响到外面的元素，为了保证这个规则，触发了 BFC 的右侧元素为了将内部元素和左侧浮动元素隔离开，不得不形成这样左右完全隔离的两栏，同时，如果右侧元素依旧是块级元素，那么他尽可能占满一行的特性还在，这样就保证了右侧元素依旧是自适应的

#### 怎么触发 BFC：

- 根元素（html），或者包含 body 的元素
- overflow 的值为非 visible（hidden，auto，scroll）
- display 的值为:inline-block,flow-root（无副作用但是不兼容 IE）,grid,flex,table,table-cell
- position 的值为:fixed 或者 absolute
- float 的值不为 none（left 或者 right）

## 常见的垂直居中的方法：

#### 对于宽高固定的元素：

- 我们可以利用 margin:0 auto 来实现元素的水平居中。
- 利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。
- 利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素
  的中心点到页面的中心。外边距为自身宽高的一半（负值）

#### 对于宽高不定的元素：

- 利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素
  的中心点到页面的中心。 transform: translate(-50%, -50%);
- 使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对
  齐，然后它的子元素也可以实现垂直和水平的居中。

## 伪类和伪元素

#### 官方解释：css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释：

- 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

- 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

## 为什么装饰器不能用于函数？

#### 装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

```js
var counter = 0;

var add = function () {
  counter++;
};

@add
function foo() {
}
```

#### 上面的代码，意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0。因为函数提升，使得实际执行的代码是下面这样。

```js
var counter;
var add;

@add
function foo() {
}

counter = 0;

add = function () {
  counter++;
};
```
