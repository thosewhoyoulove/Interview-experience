<!--
 * @Description:
 * @Author: 曹俊
 * @Date: 2022-11-07 16:45:13
 * @LastEditors: 曹俊
 * @LastEditTime: 2022-11-17 20:32:30
-->

# 项目

- 怎么封装 axios
- 项目的技术栈
- 文件路由是什么
- Vite 配置以及 vite 为什么这么快

# 八股

- Vue2 和 3 的区别
- Vue 父子组件的通信方式
- ES6 新特性（说说 proxy）
- H5 的新 API
- Promise
- 闭包
- this
- 原型和原型链
- 原型链继承和组合寄生式继承
- 数组去重
- Cookie，sessionStorage 和 localStorage
- 事件流，事件捕获和冒泡
- Keep—alive
- typescript 的掌握
- ES-module 以及 CommonJS
- 实现一个 ajax 请求的步骤
- CSS 的布局属性（详细说一下 sticky）
- 盒子垂直居中
- BFC 以及解决的问题
- CSS module
- CSS 预处理器
- git 从历史版本创建一个新分支

# 另外

- RFID 射频识别技术
- Linux
- 传感器网络
- OS 间进程通信方式
- CDN 原理

# 为什么会有 CommonJs 和 Es Module 呢：

#### 我们都知道在早期 JavaScript 模块这一概念，都是通过 script 标签引入 js 文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的 js 文件就会越多，这时就会出现以下问题：

- js 文件作用域都是顶层，这会造成变量污染
- js 文件多，变得不好维护
- js 文件依赖问题，稍微不注意顺序引入错，代码全报错

#### 为了解决以上问题 JavaScript 社区出现了 CommonJs，CommonJs 是一种模块化的规范，包括现在的 NodeJs 里面也采用了部分 CommonJs 语法在里面。那么在后来 Es6 版本正式加入了 Es Module 模块，这两种都是解决上面问题，那么都是解决什么问题呢。

- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染
- 解决代码维护问题，一个文件里代码非常清晰
- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件

### CommonJs 基本语法:

#### 导出: CommonJs 中使用 module.exports 导出变量及函数，也可以导出任意类型的值，看如下案例。

```js
// 导出一个对象
module.exports = {
  name: "蛙人",
  age: 24,
  sex: "male",
};

// 导出任意值
module.exports.name = "蛙人";
module.exports.sex = null;
module.exports.age = undefined;
```

#### 直接导出:导出也可以省略 module 关键字，直接写 exports 导出也可以，看如下案例。

```js
exports.name = "蛙人";
exports.sex = "male";
```

#### 注意：如果使用 exports 导出单个值之后，就不能再导出一个同名的对象值，这只会修改 exports 的对象改变，然而修改无效，最终导出还是 name，和 sex，因为最终的导出是由 module.exports 决定的。

## CommonJs 和 Es Module 的区别

```md
# CommonJS 模块使用 require()和 module.exports，ES6 模块使用 import 和 export。

# CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

# CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

# ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

# 这个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
```

```md
运行时加载

定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)
影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化

编译时加载

定义：直接从模块中获取需要的属性和方法进行加载(按需加载)
影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展 JS 高级语法(宏和类型校验)
```

## 什么是 BFC

### Block formatting context(块级格式化上下文)：形成一个完全独立的空间，让空间中的子元素不会影响到外面的布局。

#### 解决什么问题：

- 解决浮动元素使父元素高度塌陷
- 外边距重叠（为其中一个元素的外边包裹一层父元素，并且触发父元素 BFC）
- 浮动元素重叠（解决自适应布局的问题）：PC 端的网页，左右两栏布局很常见，一般左侧定宽，右侧主体页面宽度自适应变化，通常是用浮动来实现的；它利用了块级元素占满一行的特性，使得右边的元素可以随着页面宽度的变化而变化，又利用了浮动的特性，让左侧元素覆盖在右侧元素上方，同时还能挤开下方元素的内容，让页面看起来是两栏的效果，但随着右边元素的增加，超出了左边元素的高度后，文字就会环绕左侧元素，这显然不是我们想要的效果，因为右侧元素触发了 BFC，触发 BFC 的容器就是页面上的一个完全隔离开的容器，容器中的子元素绝对不会影响到外面的元素，为了保证这个规则，触发了 BFC 的右侧元素为了将内部元素和左侧浮动元素隔离开，不得不形成这样左右完全隔离的两栏，同时，如果右侧元素依旧是块级元素，那么他尽可能占满一行的特性还在，这样就保证了右侧元素依旧是自适应的

#### 怎么触发 BFC：

- 根元素（html），或者包含 body 的元素
- overflow 的值为非 visible（hidden，auto，scroll）
- display 的值为:inline-block,flow-root（无副作用但是不兼容 IE）,grid,flex,table,table-cell
- position 的值为:fixed 或者 absolute
- float 的值不为 none（left 或者 right）

## 常见的垂直居中的方法：

#### 对于宽高固定的元素：

- 我们可以利用 margin:0 auto 来实现元素的水平居中。
- 利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。
- 利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素
  的中心点到页面的中心。外边距为自身宽高的一半（负值）

#### 对于宽高不定的元素：

- 利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素
  的中心点到页面的中心。 transform: translate(-50%, -50%);
- 使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对
  齐，然后它的子元素也可以实现垂直和水平的居中。

## 伪类和伪元素

#### 官方解释：css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释：

- 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

- 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

## 为什么装饰器不能用于函数？

#### 装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

```js
var counter = 0;

var add = function () {
  counter++;
};

@add
function foo() {
}
```

#### 上面的代码，意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0。因为函数提升，使得实际执行的代码是下面这样。

```js
var counter;
var add;

@add
function foo() {
}

counter = 0;

add = function () {
  counter++;
};
```

## JavaScript 继承的几种实现方式？

- 第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。
- 第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。
- 第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。
- 第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。
- 第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。
- 第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## 什么是闭包，为什么要用它？

#### 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

#### 闭包有两个常用的用途。

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以
  这个变量对象不会被回收。

#### 其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。

## CDN 原理：CDN（Content Delivery Network）， 又称内容分发网络。

## 优点：

### JS 体积变小，使用 CDN 的第三方资源的 JS 代码，将不再打包到本地服务的 JS 包中。减小本地 JS 包体积，提高加载速度。

## 原理：

#### 通过`负载均衡`技术,将储存在目标服务器的资源缓存在了离终端较近的节点服务器中，等下次再获取时，就直接从节点服务器上获取。 这样就大大降低了请求获取资源的时间。比如说，北京的用户，我们让他访问北京的节点，深圳的用户，我们让他访问深圳的节点。通过就近访问，加速用户对网站的访问，进而解决 Internet 网络拥堵状况，提高用户访问网络的响应速度。

## 事件流，事件捕获与冒泡：先捕获再冒泡

```md
# 事件流：指的是事件完整执行过程中的流动路径

# 事件捕获：从 DOM 的根元素开始去执行对应的事件（从外到里）Document->html->body->div

# 事件冒泡：当一个元素的事件被触发时，同样的事件（一定要是同样的事件）会在该元素的所有祖先元素中依次被触发：div->body->html->Document，事件冒泡是默认存在的。
```

### 开启方式：Dom.addEventListener(事件类型，事件处理函数，是否开启捕获机制)

### 说明：

- addEventListener 第三个参数传入 true 代表的是捕获阶段触发（很少使用）
- 若传入 false 代表冒泡阶段触发，默认为 false
- 若是 L0 事件注册方式，只支持事件冒泡

#### 阻止冒泡：event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;

#### 鼠标经过事件：

- mouseover 和 mouseout 会有冒泡效果
- mouseenter 和 mouseleave 没有冒泡效果（推荐）

#### 阻止默认行为：event.preventDefault()

### 两种事件注册的方式：

- 传统 on 注册（L0）
  - 同一个对象，后面注册的事件会覆盖前面注册（同一个事件）
  - 直接使用 null 覆盖就可以实现事件的解绑
  - 都是冒泡阶段执行的
- 事件监听注册：
  - 语法：Dom.addEventListener(事件类型，事件处理函数，是否开启捕获机制)
  - 后面注册的事件不会覆盖前面注册（同一个事件）
  - 可以通过第三个参数去确定是在冒泡阶段或者捕获阶段执行
  - 必须使用 removeEventListener(事件类型，事件处理函数，捕获阶段或者冒泡阶段)
  - 匿名函数无法被解绑
